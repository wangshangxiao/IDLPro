;***********************************************************************************
;函数用来读取一个图象的一部分,目前只对单波段的数据进行处理,输入的参数说明如下:
;FILE_NAME	:文件的名称,文件为一个ENVI STANDARD 格式文件,要有头文件
;ROW_START	:起始的行号
;COL_START	:起始的列号
;LINES		:要读取的行数
;SAMPLES	:要读取的列数
;函数的返回值为一个结构体
;***********************************************************************************
FUNCTION READ_IMAGE_PART,FILE_IN,ROW_START,COL_START,LINES,SAMPLES

	;(1)并定义要返回的结构体,对输入的数据进行检验
	RESULT_STRUCT={   $
      		SUCCESS		:	1			, $	;数据的读取是否成功
      		P_DATA		:	PTR_NEW()	, $ ;指针,指向读取的数据(数组)
      		LINES_REAL	:	0			, $	;实际读取的数据的行数
      		SAMPLES_REAL:	0      }		;实际读取的数据的列数
	;对输入数据进行检验
    IF ((LINES LE 0) OR(SAMPLES LE 0)) THEN BEGIN
		PRINT,'起始坐标不能为负值'
		RESULT_STRUCT.SUCCESS=0
		RETURN,RESULT_STRUCT
    ENDIF

	;(2)首先检查文件是否存在
    IF (FILE_TEST(FILE_IN) EQ 0) THEN BEGIN
		PRINT,'找不到文件:'+FILE_IN+',请检查路径名!'
		RESULT_STRUCT.SUCCESS=0
		RETURN,RESULT_STRUCT
    ENDIF

    ;(3)再检查头文件是否存在,有一些信息需要从头文件中获得
    INDEX = STRPOS(FILE_IN, '.')
    HEAD1 = ''
    IF INDEX EQ -1 THEN BEGIN
      	INHEAD=STRTRIM(FILE_IN,2)+'.HDR'
    ENDIF ELSE BEGIN
      	HEAD1 = STRMID(FILE_IN,0,INDEX)
      	INHEAD=HEAD1+'.HDR'
    ENDELSE
    FINDRESULT=FINDFILE(INHEAD)
    IF (FINDRESULT[0] EQ '') THEN BEGIN
       	PRINT,INHEAD+'头文件不存在或文件格式错误,请检查!'
       	RESULT_STRUCT.SUCCESS=0
       	RETURN,RESULT_STRUCT
    ENDIF

 	;(4)从头文件中读取必要的信息
    OPENR,LUN,INHEAD,/GET_LUN
    RESULT = FSTAT(LUN)
    HEADDATA = BYTARR(RESULT.SIZE-1)
    READU,LUN,HEADDATA
    FREE_LUN,LUN
    HEADFILE=STRING(HEADDATA)
    FREE_LUN,LUN

	;获取行列号，波段数，左上角坐标
    INDEX0 = STRPOS(HEADFILE, 'samples = ')
    INDEX1 = STRPOS(HEADFILE, 'lines   = ')
    INDEX2 = STRPOS(HEADFILE, 'bands   = ')
    INDEX3 = STRPOS(HEADFILE, 'header offset = ')
    INDEX4 = STRPOS(HEADFILE, 'map info = ')
    INDEX5 = STRPOS(HEADFILE, 'projection info = ')
    INDEX6 = STRPOS(HEADFILE, 'data type = ')
    INDEX7 = STRPOS(HEADFILE, 'interleave = ')
    INDEX8 = STRPOS(HEADFILE, 'pixel size = ')
    SAMPLES_FILE 	= STRMID(HEADFILE,INDEX0+10,INDEX1-INDEX0-10-1)
    SAMPLES_FILE=LONG(SAMPLES_FILE)
    LINES_FILE 		=  STRMID(HEADFILE,INDEX1+10,INDEX2-INDEX1-10-1)
    LINES_FILE=LONG(LINES_FILE)
    BANDS=STRMID(HEADFILE,INDEX2+10,INDEX3-INDEX2-10-1)
    DATA_TYPE=STRMID(HEADFILE,INDEX6+12,INDEX7-INDEX6-12-1)
    ;起始点坐标的获取
    INFO=STRMID(HEADFILE,INDEX4+11,INDEX5-INDEX4-13)
    INDEX41= STRPOS(INFO,',')
    INFO2=STRMID(HEADFILE,INDEX4+11+INDEX41+1,INDEX5-(INDEX4+11+INDEX41)-3)
    INDEX42= STRPOS(INFO2,',')
    INFO3=STRMID(HEADFILE,INDEX4+11+INDEX41+1+INDEX42+1,INDEX5-(INDEX4+11+INDEX41+1+INDEX42)-3)
    INDEX43= STRPOS(INFO3,',')
    INFO4=STRMID(HEADFILE,INDEX4+11+INDEX41+1+INDEX42+1+INDEX43+1,INDEX5-(INDEX4+11+INDEX41+1+INDEX42+1+INDEX43)-3)
    INDEX44= STRPOS(INFO4,',')
    INFO5=STRMID(HEADFILE,INDEX4+11+INDEX41+1+INDEX42+1+INDEX43+1+INDEX44+1,INDEX5-(INDEX4+11+INDEX41+1+INDEX42+1+INDEX43+1+INDEX44)-3)
    INDEX45=STRPOS(INFO5,',')
    SULX=STRMID(INFO4,0,INDEX44)
    SULY=STRMID(INFO5,0,INDEX45)
    ;像元大小的获取,假设X，Y是一样大小，否则得分别提取X、Y的大小
    INFO80=STRMID(HEADFILE,INDEX8+14,30)
    INDEX81=STRPOS(INFO80,',')
    PIXEL_SIZE=STRMID(HEADFILE,INDEX8+14,INDEX81)

	;将获取的信息转换为整型
    X_SIZE=LONG(SAMPLES_FILE)
    Y_SIZE=LONG(LINES_FILE)
    BANDNUM=LONG(BANDS)
    DATATP=LONG(DATA_TYPE)
    ULX=LONG(SULX)
    ULY=LONG(SULY)
    PIXELSIZE=FLOAT(PIXEL_SIZE)

	;(5)计算文件实际要读取的数据的大小
	;,这是因为实际能读取出来的数据很可能比想读取出来的数据小
	;HELP,COL_START,X_SIZE
	IF((COL_START GT X_SIZE) OR (ROW_START GT Y_SIZE)) THEN BEGIN

		PRINT,'要读取的数据范围全部在图像以外'
		RESULT_STRUCT.SUCCESS=0
        RETURN,RESULT_STRUCT
	ENDIF
	IF(COL_START+SAMPLES-1 GT X_SIZE) THEN BEGIN
		SAMPLES=X_SIZE-COL_START+1
	ENDIF
	IF(ROW_START+LINES-1 GT Y_SIZE) THEN BEGIN
		LINES=Y_SIZE-ROW_START+1
	ENDIF

	;(6)根据数据的类型进行数组的定义
    CASE DATATP OF
      1: BEGIN
             INDATA		=BYTARR(SAMPLES,LINES)	;用来放最后返回的数据
             DATA_LINE	=BYTARR(SAMPLES)		;用来放一行的数据
             TPSIZE		=1
         END
      2: BEGIN
             INDATA		=INTARR(SAMPLES,LINES)
             DATA_LINE	=INTARR(SAMPLES)
             TPSIZE		=2
         END
      4: BEGIN
             INDATA		=FLTARR(SAMPLES,LINES)
             DATA_LINE	=FLTARR(SAMPLES)
             TPSIZE		=4
         END
      12:BEGIN
             INDATA		=UINTARR(SAMPLES,LINES)
             DATA_LINE	=UINTARR(SAMPLES)
             TPSIZE		=2
         END
      13:BEGIN
             INDATA		=ULONARR(SAMPLES,LINES)
             DATA_LINE	=ULONARR(SAMPLES)
             TPSIZE		=4
         END
      ELSE:BEGIN
             PRINT,FILE_IN+'@@'+DATA_TYPE+':没有定义此数据类型!'
             RESULT_STRUCT.SUCCESS=0
             RETURN,RESULT_STRUCT
         END
    ENDCASE

	;(7)打开文件,并进行数据的读取
    OPENR,LUN,FILE_IN,/GET_LUN
    ;在这里还对读入数据的大小进行了验证
    FILESIZE=FSTAT(LUN)
    IF FILESIZE.SIZE NE LONG(X_SIZE)*Y_SIZE*TPSIZE THEN BEGIN
       	;PRINT,FILE_IN+'头文件信息与文件大小不一致，请检查!'
       	RESULT_STRUCT.SUCCESS=0
        RETURN,RESULT_STRUCT
    END
    FILESIZE=0

    ;进行文件起始位置的计算
    ;!!!!ROW_START是从零开始的
    POSITION=((LONG64(ROW_START))*SAMPLES_FILE+COL_START-1+1)*TPSIZE
    POSITION=POSITION-SAMPLES_FILE*TPSIZE

    ;HELP,POSITION
    ;加上这句主要是为了第次循环都可以加SAMPLES
	;HELP,INDATA,DATA_LINE,TPSIZE
    FOR I=0,LINES-1 DO BEGIN
    	IF(I EQ 1934) THEN PRINT,'AAAAAA',POSITION
    	POSITION=POSITION+SAMPLES_FILE*TPSIZE
    	POINT_LUN,LUN,POSITION
    	READU,LUN,DATA_LINE
    	INDATA[*,I]=DATA_LINE[0:SAMPLES-1]
    ENDFOR

    FREE_LUN,LUN
    RESULT_STRUCT.P_DATA=PTR_NEW(INDATA)
    ;PRINT,'HERE'
    RETURN,RESULT_STRUCT

END